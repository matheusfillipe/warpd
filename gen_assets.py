#!/usr/bin/env python3

# Copyright Â© 2019 Raheman Vaiya.
#
# Permission is hereby granted, free of charge, to any person obtaining a
# copy of this software and associated documentation files (the "Software"),
# to deal in the Software without restriction, including without limitation
# the rights to use, copy, modify, merge, publish, distribute, sublicense,
# and/or sell copies of the Software, and to permit persons to whom the
# Software is furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice (including the next
# paragraph) shall be included in all copies or substantial portions of the
# Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
# THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
# DEALINGS IN THE SOFTWARE.

# cfg.opts should consist of lines of the following form:
# <option/field name> <type (must be string, int, or double)> <default val>

import sys
import re
import glob
import os

h_template = '''//GENERATED BY %s.

#ifndef _CFG_H_
#define _CFG_H_

struct cfg {
{struct_fields}
};

struct cfg* parse_cfg(const char *fname);

#endif
''' % sys.argv[0]

c_template = r'''//GENERATED BY {script}

#include <stdio.h>
#include <ctype.h>
#include <string.h>
#include <stdlib.h>
#include "{header_file}"

static int kvp(char *line, char **key, char **val) {
  *key = NULL;
  *val = NULL;
  
  for(;*line != '\0';line++) {
    if(*line != ' ' && !*key)
      *key = line;
    
    if(*line == ':' && !*val) {
      *line++ = '\0';
      for(;isspace(*line);line++);
      *val = line;
    }
  }
  
  if(*(line - 1) == '\n')
    *(line - 1) = '\0';
  
  if(!(*val && *key))
    return -1;
  
  return 0;
}

struct cfg* parse_cfg(const char *fname) {
    char *line = NULL;
    size_t n = 0, ln = 0;
    struct cfg *cfg = malloc(sizeof(struct cfg));

{field_init}

    FILE *fp = fopen(fname, "r");
    if(!fp) return cfg; //Return defaults if no config file xists..
    while(getline(&line, &n, fp) != -1) {
        ln++;
        char *key, *val;

        if(line[0] == '\n' || line[0] == '\0') continue;

        if(kvp(line, &key, &val)) {
            fprintf(stderr, "Invalid entry in %s at line %lu.\n", fname, ln);
            exit(1);
        }

{field_checks}

        free(line);
        line = NULL;
        n = 0;
    }

    return cfg;
}
'''.replace('{script}', sys.argv[0])


conversion_map = {
    'string': 'strdup',
    'int': 'atoi',
    'double': 'atof',
}


def generate_h(options):
    struct_fields = ''
    for fld, typ, _, _ in options:
        struct_fields += '    %s %s;\n' % ('char*' if typ ==
                                           'string' else typ, fld)

    return h_template.replace('{struct_fields}', struct_fields.rstrip())


def generate_c(options, header_file):
    field_init = ''
    for fld, typ, default, _ in options:
        field_init += '    cfg->%s = %s;\n' % (
            fld, ('"%s"' % default) if typ == "string" else default)

    field_checks = ''

    cond = 'if'
    for fld, typ, _, _ in options:
        field_checks += '''\
        %s(!strcmp(key, "%s"))
            cfg->%s = %s(val);\n''' % (cond, fld, fld, conversion_map[typ])
        cond = 'else if'

    return c_template\
        .replace('{field_checks}', field_checks.rstrip())\
        .replace('{field_init}', field_init.rstrip())\
        .replace('{header_file}', header_file)


def parse_line(l):
    m = re.match('^(\S*) +(\S*) +"([^"]*)" +"([^"]*)"$', l)
    if not m:
        m = re.match('^(\S*) +(\S*) +(\S*) +"([^"]*)"$', l)

    return m[1], m[2], m[3], m[4]


def read_opts(fname):
    ln = 0
    opts = []
    for l in open(fname, 'r').read().rstrip().split('\n'):
        ln += 1
        if l == '':
            continue

        opts.append(parse_line(l))

    return opts


opts = read_opts('cfg.opts')
header = generate_h(opts)
c = generate_c(opts, 'cfg.h')

optstr = ''
for name, _, val, desc in opts:
    optstr += '**%s**: %s (default: %s).\n\n' % (name, desc, val)

print("Generating README.md")
print("man.md")
open('man.md', 'w').write(
    open('man.md.t', 'r').read().replace('{opts}', optstr))
print("Generating src/cfg.c")
open('src/cfg.c', 'w').write(c)
print("Generating src/cfg.h")
open('src/cfg.h', 'w').write(header)
